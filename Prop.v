(* File: Prop.v *)
(* Title: Prop - Propositions and Evidence *)
(* Author: Peter Urbak <peteru@dragonwasrobot.com> *)
(* Version: 2012-09-24 *)

Require Export Poly.

(* Inductively Defined Propositions *)

(* Exercise: 1 star (varieties_of_beauty) *)

(*
   Six:
   - (3 + 5)
   - (5 + 3)
   - (0 + (3 + 5))
   - (0 + (5 + 3))
   - ((3 + 5) + 0)
   - ((5 + 3) + 0)
*)

Inductive beautiful : nat -> Prop :=
  | b_0 : beautiful 0
  | b_3 : beautiful 3
  | b_5 : beautiful 5
  | b_sum : forall n m, beautiful n -> beautiful m -> beautiful (n + m).

Theorem three_is_beautiful : beautiful 3.
Proof.
  (* This simply follows from the axiom b_3. *)
  apply b_3.
Qed.

Theorem eight_is_beautiful : beautiful 8.
Proof.
  (* First we use the rule b_sum, telling Coq how to instantiate n and m. *)
  apply b_sum with (n:=3) (m:=5).
  (* To solve the subgoals generated by b_sum, we must provide evidence of
      beautiful 3 and beautiful 5. Fortunately we have axioms for both. *)
  apply b_3.
  apply b_5.
Qed.

(* Curry-Howard Correspondence *)
(*     Propositions - Types    *)
(*         Evidence - Data     *)

Check (b_sum 3 5 b_3 b_5).

Theorem eight_is_beautiful' : beautiful 8.
Proof.
  apply (b_sum 3 5 b_3 b_5).
Qed.

(* Proof Scripts and Proof Objects *)

Theorem eight_is_beautiful'' : beautiful 8.
Proof.
  apply b_sum with (n:=3) (m:=5).
  Show Proof.
  apply b_3.
  Show Proof.
  apply b_5.
  Show Proof.
Qed.

Definition eight_is_beautiful''' : beautiful 8 :=
  b_sum 3 5 b_3 b_5.

Print eight_is_beautiful.
(* ===> eight_is_beautiful = b_sum 3 5 b_3 b_5 : beautiful 8 *)
Print eight_is_beautiful'.
(* ===> eight_is_beautiful' = b_sum 3 5 b_3 b_5 : beautiful 8 *)
Print eight_is_beautiful''.
(* ===> eight_is_beautiful'' = b_sum 3 5 b_3 b_5 : beautiful 8 *)
Print eight_is_beautiful'''.
(* ===> eight_is_beautiful''' = b_sum 3 5 b_3 b_5 : beautiful 8 *)

(* Exercise: 1 star (six_is_beautiful) *)

Theorem six_is_beautiful :
  beautiful 6.
Proof.
  apply (b_sum 3 3 b_3 b_3).
Qed.

Definition six_is_beautiful' : beautiful 6 :=
  b_sum 3 3 b_3 b_3.

(* Exercise : 1 star (nine_is_beautiful) *)

Theorem nine_is_beautiful :
  beautiful 9.
Proof.
  apply (b_sum 6 3 six_is_beautiful b_3).
Qed.

Definition nine_is_beautiful' : beautiful 9 :=
  b_sum 6 3 six_is_beautiful b_3.

(* Implications and Functions *)

Theorem b_plus3 : forall n, beautiful n -> beautiful (3 + n).
Proof.
  intros n H.
  apply b_sum.
  apply b_3.
  apply H.
Qed.

Definition b_plus3' : forall n, beautiful n -> beautiful (3 + n) :=
  fun n => fun H : beautiful n =>
    b_sum 3 n b_3 H.
Check b_plus3'.
(* ===> b_plus3' : forall n : nat, beautiful n -> beautiful (3 + n) *)

Definition b_plus3'' (n : nat) (H : beautiful n) : beautiful (3 + n) :=
  b_sum 3 n b_3 H.
Check b_plus3''.
(* ===> b_plus3' : forall n : nat, beautiful n -> beautiful (3 + n) *)

(* Exercise: 2 stars (b_times2) *)
Theorem b_times2 : forall n, beautiful n -> beautiful (2 * n).
Proof.
  intros.
  apply (b_sum n (n + 0)).
  apply H.
  rewrite -> plus_O_r.
  apply H.
Qed.

(* Exercise: 3 stars, optional (b_times2') *)
Definition b_times2' : forall n, beautiful n -> beautiful (2 * n) :=
  fun n => fun H : beautiful n =>
    (b_sum n (n + 0) H (eq_ind_r (fun n' => beautiful n') H (plus_O_r n))).

(* Exercise: 2 stars (b_timesm) *)
Theorem b_timesm : forall n m, beautiful n -> beautiful (m * n).
Proof.
  intros.
  induction m as [ | m' ].

  Case "m = O".
  rewrite mult_O_l.
  apply b_0.

  Case "m = S m'".
  unfold mult.
  fold mult.
  apply (b_sum n (m' * n)).

  apply H.

  apply IHm'.
Qed.

(* Induction over Proof Objects *)

Inductive gorgeous : nat -> Prop :=
  | g_0 : gorgeous 0
  | g_plus3 : forall n, gorgeous n -> gorgeous (3 + n)
  | g_plus5 : forall n, gorgeous n -> gorgeous (5 + n).

(* Exercise: 1 star (gorgeous_tree) *)

(*
----------
gorgeous 0

   gorgeous n
----------------
gorgeous (3 + n)

   gorgeous n
----------------
gorgeous (5 + n)

*)

Theorem gorgeous__beautiful : forall n,
  gorgeous n -> beautiful n.
Proof.
  intros.
  (* The argument proceeds by induction on the evidence H! *)
  induction H as [|n'|n'].

  Case "g_0".
  apply b_0.

  Case "g_plus3".
  apply b_sum. apply b_3.
  apply IHgorgeous.

  Case "g_plus5".
  apply b_sum. apply b_5. apply IHgorgeous.
Qed.

(* Exercise: 1 star (gorgeous_plus13) *)

Theorem gorgeous_plus13 : forall n,
  gorgeous n -> gorgeous (13 + n).
Proof.
  intros.
  induction H as [ | n' | n' ].

  Case "g_0".
  rewrite -> plus_O_r.

  assert (H13: 13 = 5 + 8). reflexivity.
  rewrite -> H13. apply g_plus5.

  assert (H8: 8 = 5 + 3). reflexivity.
  rewrite -> H8. apply g_plus5.

  assert (H5: 3 = 3 + 0). reflexivity.
  rewrite -> H5. apply g_plus3.

  apply g_0.

  Case "g_plus3".
  rewrite plus_comm.
  rewrite <- plus_assoc.
  apply g_plus3.
  rewrite plus_comm.
  apply IHgorgeous.

  Case "g_plus5".
  rewrite plus_comm.
  rewrite <- plus_assoc.
  apply g_plus5.
  rewrite plus_comm.
  apply IHgorgeous.
Qed.
(* I hope there's an easier solution that the above *)

(* Exercise: 2 stars (gorgeous_plus13_po) *)
Print gorgeous_plus13.

Definition gorgeous_plus13_po : forall n, gorgeous n -> gorgeous (13 + n) :=
fun (n : nat) (H : gorgeous n) =>
gorgeous_ind (fun n0 : nat => gorgeous (13 + n0))
  (let Case := "g_0" in
   eq_ind_r (fun n0 : nat => gorgeous n0)
     (let H13 := eq_refl (5 + 8) in
      eq_ind_r (fun n0 : nat => gorgeous n0)
        (g_plus5 8
           (let H8 := eq_refl (5 + 3) in
            eq_ind_r (fun n0 : nat => gorgeous n0)
              (g_plus5 3
                 (let H5 := eq_refl (3 + 0) in
                  eq_ind_r (fun n0 : nat => gorgeous n0) (g_plus3 0 g_0) H5))
              H8)) H13) (plus_O_r 13))
  (fun (n' : nat) (_ : gorgeous n') (IHgorgeous : gorgeous (13 + n')) =>
   let Case := "g_plus3" in
   eq_ind_r (fun n0 : nat => gorgeous n0)
     (eq_ind (3 + (n' + 13)) (fun n0 : nat => gorgeous n0)
        (g_plus3 (n' + 13)
           (eq_ind_r (fun n0 : nat => gorgeous n0) IHgorgeous
              (plus_comm n' 13))) (3 + n' + 13) (plus_assoc 3 n' 13))
     (plus_comm 13 (3 + n')))
  (fun (n' : nat) (_ : gorgeous n') (IHgorgeous : gorgeous (13 + n')) =>
   let Case := "g_plus5" in
   eq_ind_r (fun n0 : nat => gorgeous n0)
     (eq_ind (5 + (n' + 13)) (fun n0 : nat => gorgeous n0)
        (g_plus5 (n' + 13)
           (eq_ind_r (fun n0 : nat => gorgeous n0) IHgorgeous
              (plus_comm n' 13))) (5 + n' + 13) (plus_assoc 5 n' 13))
     (plus_comm 13 (5 + n'))) n H.

Check gorgeous_plus13.
Check gorgeous_plus13_po.

(* Exercise: 2 stars (gorgeous_sum) *)

Theorem gorgeous_sum : forall n m,
  gorgeous n -> gorgeous m -> gorgeous (n + m).
Proof.
  intros n m Hn Hm.
  induction Hn.

  Case "g_0".
  rewrite -> plus_O_n.
  apply Hm.

  Case "g_plus3".
  rewrite <- plus_assoc.
  apply g_plus3.
  apply IHHn.

  Case "g_plus5".
  rewrite <- plus_assoc.
  apply g_plus5.
  apply IHHn.
Qed.

(* Exercise: 3 stars (beautiful__gorgeous) *)

Theorem beautiful__gorgeous : forall n, beautiful n -> gorgeous n.
Proof.
  intros n H_beautiful_n.
  induction H_beautiful_n.

  Case "b_0".
  apply g_0.

  Case "b_3".

  assert (H3: 3 = 3 + 0). reflexivity.

  rewrite -> H3. apply g_plus3.
  apply g_0.

  Case "b_5".

  assert (H5: 5 = 5 + 0). reflexivity.

  rewrite -> H5. apply g_plus5.
  apply g_0.

  Case "b_sum".
  apply gorgeous_sum.
  apply IHH_beautiful_n1.
  apply IHH_beautiful_n2.
Qed.

(* Exercise: 3 stars, optional (b_times2) *)

Lemma helper_g_times2 : forall x y z, x + (z + y) = z + x + y.
Proof.
  intros.
  rewrite <- plus_assoc.
  rewrite <- plus_comm.
  rewrite (plus_comm x y).
  rewrite <- plus_assoc.
  reflexivity.
Qed.

Theorem g_times2 : forall n, gorgeous n -> gorgeous (2 * n).
Proof.
  intros n H_gorgeous_n.
  induction H_gorgeous_n.

  Case "g_0".
  rewrite -> mult_O_r.
  apply g_0.

  Case "g_plus3".
  unfold mult; fold mult.
  rewrite <- plus_assoc.
  apply g_plus3.

  rewrite -> helper_g_times2.
  rewrite <-2 plus_assoc.
  apply g_plus3.

  assert (Hdouble: 2 * n = n + n).
  unfold mult; fold mult; rewrite -> plus_O_r; reflexivity.

  rewrite -> plus_O_r.
  rewrite <- Hdouble.
  apply IHH_gorgeous_n.

  Case "g_plus_5".
  unfold mult; fold mult.
  rewrite <- plus_assoc.
  apply g_plus5.

  rewrite -> helper_g_times2.
  rewrite <-2 plus_assoc.
  apply g_plus5.

  assert (Hdouble: 2 * n = n + n).
  unfold mult; fold mult; rewrite -> plus_O_r; reflexivity.

  rewrite -> plus_O_r.
  rewrite <- Hdouble.
  apply IHH_gorgeous_n.
Qed.

(* Evenness *)

Definition even (n : nat) : Prop :=
  evenb n = true.

Inductive ev : nat -> Prop :=
  | ev_O : ev O
  | ev_SS : forall n : nat, ev n -> ev (S (S n)).

(* Exercise: 1 star (double_even) *)

Theorem double_even : forall n,
  ev (double n).
Proof.
  intros.
  induction n as [ | n' ].

  Case "n = O".
  unfold double.
  apply ev_O.

  Case "n = S n'".
  unfold double; fold double.
  apply ev_SS.
  apply IHn'.
Qed.

(* Exercise: 4 stars, optional (double_even_pfobj) *)

(*
fun n : nat =>
nat_ind (fun n0 : nat => ev (double n0)) (let Case := "n = O" in ev_O)
  (fun (n' : nat) (IHn' : ev (double n')) =>
   let Case := "n = S n'" in ev_SS (double n') IHn') n
     : forall n : nat, ev (double n)
*)

(* Inverting Evidence *)

Theorem ev_minus2 : forall n,
  ev n -> ev (pred (pred n)).
Proof.
  intros n E.
  destruct E as [ | n' E' ].

  Case "E = ev_0".
  simpl.
  apply ev_O.

  Case "E = ev_SS n' E'".
  simpl.
  apply E'.
Qed.

(* Exercise: 1 star, optional (ev_minus2_n) *)

(* Induction has to be on even natural numbers and not just natural numbers. *)

(* Exercise: 1 star, recommended (ev_even) *)

Theorem ev__even : forall n,
  ev n -> even n.
Proof.
  intros n E.
  induction E as [ | n' E' ].

  Case "E = ev_0".
  unfold even.
  reflexivity.

  Case "E = ev_SS n' E'".
  unfold even.
  apply IHE'.
Qed.

(* Induction on natural numbers rather than even numbers -> won't work. *)

(* Exercise: 1 star (l_fails) *)

(* Once again, it tries to do induction over natural numbers, instead of even *)
(* natural numbers. *)

(* Exercise: 2 stars (ev_sum) *)

Theorem ev_sum : forall n m,
  ev n -> ev m -> ev (n + m).
Proof.
  intros n m E_n E_m.
  induction E_n as [ | n' E' ].

  Case "E_n = ev_O".
  rewrite -> plus_O_n.
  apply E_m.

  Case "E_n = ev_SS n' E'".
  rewrite -> plus_comm.
  rewrite <-2 plus_n_Sm.
  apply ev_SS.
  rewrite -> plus_comm.
  apply IHE'.
Qed.

Theorem SSev_ev_secondtry : forall n,
  ev (S (S n)) -> ev n.
Proof.
  intros n E. remember (S (S n)) as n2.
  destruct E as [| n' E'].
  Case "n = 0". inversion Heqn2.
  Case "n = S n'". inversion Heqn2. rewrite <- H0. apply E'.
Qed.

Theorem SSev_even : forall n,
  ev (S (S n)) -> ev n.
Proof.
  intros n E.
  inversion E as [ | n' E' ].
  apply E'.
Qed.

(* Exercise: 1 star (inversion_practice) *)

Theorem SSSSev_even : forall n,
  ev (S (S (S (S n)))) -> ev n.
Proof.
  intros n E.
  inversion E as [ | n' E_S_S_n ].
  inversion E_S_S_n as [ | n'' E_n ].
  apply E_n.
Qed.

Theorem even5_nonsense :
  ev 5 -> 2 + 2 = 9.
Proof.
  intro E.
  inversion E as [ | n' E3 H3 ].
  inversion E3 as [ | n'' E1 H1 ].
  inversion E1.
Qed.

Theorem ev_minus2' : forall n,
  ev n -> ev (pred (pred n)).
Proof.
  intros n E.
  inversion E as [ | n' E' ].

  Case "E = ev_O".
  simpl.
  apply ev_O.

  Case "E = ev_SS n' E'".
  simpl.
  apply E'.
Qed.

(* Exercise: 3 stars (ev_ev__ev) *)

Theorem ev_ev__ev : forall n m,
  ev (n + m) -> ev n -> ev m.
Proof.
  intros n m E_n_m E_n.
  induction E_n as [ | n' E_n' ].

  Case "E = ev_O".
  apply E_n_m.

  Case "E = ev_SS n' E'".
  apply IHE_n'.
  inversion E_n_m.
  apply H0.
Qed.

(* Exercise: 3 stars, optional (ev_plus_plus) *)

Theorem ev_plus_plus : forall n m p,
  ev (n + m) -> ev (n + p) -> ev (m + p).
Proof.
  intros n m p.
  intros E_n_m.
  rewrite (plus_comm m p).
  apply ev_ev__ev.
  rewrite (plus_comm n p).
  rewrite plus_swap.
  rewrite -> plus_assoc.
  rewrite -> plus_assoc.
  rewrite <- plus_assoc.
  apply ev_sum.
  rewrite <- double_plus.
  apply double_even.
  apply E_n_m.
Qed.

(* Programming with Propositions *)

Check (2 + 2) = 4.
(* ==> 2 + 2 = 4 : Prop *)

Check (ble_nat 3 2 = false).
(* ==> ble_nat 3 2 = false : Prop *)

Check (beautiful 8).
(* ==> beautiful 8 : Prop *)

Check (2 + 2 = 5).
(* ==> 2 + 2 = 5 : Prop *)

Check (beautiful 4).
(* ==> beautiful 4 : Prop *)

Theorem plus_2_2_is_4 :
  2 + 2 = 4.
Proof. reflexivity. Qed.

Definition plus_fact : Prop := 2 + 2 = 4.
Check plus_fact.
(* ==> plus_fact : Prop *)

Theorem plus_fact_is_true :
  plus_fact.
Proof. reflexivity. Qed.

Definition strange_prop1 : Prop :=
  (2 + 2 = 5) -> (99 + 26 = 42).

Definition strange_prop2 : Prop :=
  forall n, (ble_nat n 17 = true) -> (ble_nat n 99 = true).

Check even.
(* ===> even : nat -> Prop *)

Check (even 4).
(* ==> even 4 : Prop *)

Check (even 3).
(* ==> even 3 : Prop *)

Definition even_n__even_SSn (n : nat) : Prop :=
  (even n) -> (even (S (S n))).

Definition between (n m o : nat) : Prop :=
  andb (ble_nat n o) (ble_nat o m) = true.

Definition teen : nat -> Prop := between 13 19.

Definition true_for_zero (P : nat -> Prop) : Prop :=
  P O.

Definition true_for_n__true_for_Sn (P : nat -> Prop) (n : nat) : Prop :=
  P n -> P (S n).

Definition true_for_all_numbers (P : nat -> Prop) : Prop :=
  forall n, P n.

Definition preserved_by_S (P : nat -> Prop) : Prop :=
  forall n', P n' -> P (S n').

Definition our_nat_induction (P : nat -> Prop) : Prop :=
  (true_for_zero P) ->
  (preserved_by_S P) ->
  (true_for_all_numbers P).

(* Induction Principles *)

(* Induction Principles for Inductively Defined Types *)

Check nat_ind.
(*  ===> nat_ind : forall P : nat -> Prop,
                      P 0  ->
                      (forall n : nat, P n -> P (S n))  ->
                      forall n : nat, P n  *)

Theorem mult_O_r' : forall n : nat,
  n * O = O.
Proof.
  apply nat_ind.
  Case "O". reflexivity.
  Case "S". simpl. intros n IHn. rewrite -> IHn.
  reflexivity.
Qed.

(* Exercise: 2 stars (plus_one_r') *)

(* Okay, so we are probably supposed to use nat_ind for this guy, since it would
   otherwise be quite trivial by just using plus_comm and plus_1_l. *)
Theorem plus_one_r' : forall n : nat,
  n + 1 = S n.
Proof.
  apply nat_ind.

  Case "O".
  unfold plus.
  reflexivity.

  Case "S".
  intros n IHn.
  rewrite <- plus_n_Sm.
  rewrite <- IHn.
  rewrite <- plus_n_O.
  reflexivity.
Qed.

Inductive yesno : Type :=
  | yes : yesno
  | no : yesno.

Check yesno_ind.
(* ===> yesno_ind : forall P : yesno -> Prop,
                      P yes  ->
                      P no  ->
                      forall y : yesno, P y *)

(* Exercise: 1 star (rgb) *)

Inductive rgb : Type :=
  | red : rgb
  | green : rgb
  | blue : rgb.

Check rgb_ind.
(* ===> rgb_ind : forall P : rgb -> Prop,
                    P red ->
                    P green ->
                    P blue ->
                    forall r : rgb, P r *)

Inductive natlist : Type :=
  | nnil : natlist
  | ncons : nat -> natlist -> natlist.

Check natlist_ind.
(* ===> natlist_ind : forall P : natlist -> Prop,
                        P nnil ->
                        (forall (n : nat) (n0 : natlist), P n0 -> P (ncons n n0)) ->
                        forall n : natlist, P n *)

(* Exercise: 1 star (natlist1) *)

Inductive natlist1 : Type :=
  | nnil1 : natlist1
  | nsnoc1 : natlist1 -> nat -> natlist1.

Check natlist1_ind.
(* ===> natlist1_ind : forall P : natlist1 -> Prop,
                         P nnil1 ->
                         (forall n : natlist1, P n -> forall n0 : nat,
                                          P (nsnoc1 n n0)) ->
                         forall n : natlist1, P n *)

(* Exercise: 1 star (ExSet) *)

(* ExSet_ind :
          forall P : ExSet -> Prop,
              (forall b : bool, P (con1 b)) ->
              (forall(n : nat) (e : ExSet), P e -> P (con2 n e)) →
              forall e : ExSet, P e *)

Inductive ExSet : Type :=
  | con1 : bool -> ExSet
  | con2 : nat -> ExSet -> ExSet.

Check ExSet_ind.

(*
Inductive list (X:Type) : Type :=
        | nil : list X
        | cons : X -> list X -> list X.

 ===> list_ind :
         forall (X : Type) (P : list X -> Prop),
            P [] ->
            (forall (x : X) (l : list X), P l -> P (x :: l)) →
            forall l : list X, P l
*)

(* Exercise: 1 star (tree) *)

Inductive tree (X : Type) : Type :=
  | leaf : X -> tree X
  | node : tree X -> tree X -> tree X.

Check tree_ind.
(* ===> tree_ind : forall (X : Type) (P : tree X -> Prop),
       (forall x : X, P (leaf X x)) ->
       (forall t : tree X, P t -> forall t0 : tree X, P t0 -> P (node X t t0)) ->
       forall t : tree X, P t *)

(* Exercise: 1 star (mytype) *)

(* mytype_ind :
        forall (X : Type) (P : mytype X -> Prop),
            (forall x : X, P (constr1 X x)) ->
            (forall n : nat, P (constr2 X n)) ->
            (forall m : mytype X, P m ->
               forall n : nat, P (constr3 X m n)) ->
            forall m : mytype X, P m *)

Inductive mytype (X : Type) : Type :=
  | constr1 : X -> mytype X
  | constr2 : nat -> mytype X
  | constr3 : mytype X -> nat -> mytype X.

Check mytype_ind.

(* Exercise: 1 star, optional (foo) *)

(* foo_ind :
        forall (X Y : Type) (P : foo X Y -> Prop),
             (forall x : X, P (bar X Y x)) ->
             (forall y : Y, P (baz X Y y)) ->
             (forall f1 : nat -> foo X Y,
               (forall n : nat, P (f1 n)) -> P (quux X Y f1)) ->
             forall f2 : foo X Y, P f2 *)

Inductive foo (X Y : Type) : Type :=
  | bar  : X -> foo X Y
  | baz  : Y -> foo X Y
  | quux : (nat -> foo X Y) -> foo X Y.

Check foo_ind.

(* Exercise: 1 star, optional (foo') *)

Inductive foo' (X:Type) : Type :=
  | C1 : list X -> foo' X -> foo' X
  | C2 : foo' X.

Check foo'_ind.
(* ===> foo'_ind : forall (X : Type) (P : foo' X -> Prop),
       (forall (l : list X) (f : foo' X), P f -> P (C1 X l f)) ->
       P (C2 X) -> forall f1 : foo' X, P f1 *)

(* Induction Hypotheses *)

Definition P_mOr (n : nat) : Prop :=
  n * O = O.

Definition P_mOr' : nat -> Prop :=
  fun n => n * O = O.

Theorem mult_O_r'' : forall n : nat,
  P_mOr n.
Proof.
  apply nat_ind.

  Case "n = O".
  reflexivity.

  Case "n = S n'".
  unfold P_mOr.
  simpl.
  intros n' IHn'.
  apply IHn'.
Qed.

(* Optional Material *)

Check gorgeous_ind.
(* ===>  gorgeous_ind
     : forall P : nat -> Prop,
       P 0 ->
       (forall n : nat, gorgeous n -> P n -> P (3 + n)) ->
       (forall n : nat, gorgeous n -> P n -> P (5 + n)) ->
       forall n : nat, gorgeous n -> P n *)

Theorem gorgeous__beautiful' : forall n, gorgeous n -> beautiful n.
Proof.
  intros.
  apply gorgeous_ind.

  Case "g_O".
  apply b_0.

  Case "g_plus3".
  intros.
  apply b_sum.
  apply b_3.
  apply H1.

  Case "g_plus5".
  intros.
  apply b_sum.
  apply b_5.
  apply H1.

  apply H.
Qed.

(* Exercise: 3 stars, optional (p_provability) *)

Module P.

Inductive p : (tree nat) -> nat -> Prop :=
  | c1 : forall n, p (leaf _ n) 1
  | c2 : forall t1 t2 n1 n2,
    p t1 n1 -> p t2 n2 -> p (node _ t1 t2) (n1 + n2)
  | c3 : forall t n, p t n -> p t (S n).

(* bla bla *)

End P.

(* More on the induction Tactic *)

Theorem plus_assoc' : forall n m p : nat,
  n + (m + p) = (n + m) + p.
Proof.
  (* ...we first introduce all 3 variables into the context,
     which amounts to saying "Consider an arbitrary n, m, and
     p..." *)
  intros n m p.
  (* ...We now use the induction tactic to prove P n (that
     is, n + (m + p) = (n + m) + p) for _all_ n,
     and hence also for the particular n that is in the context
     at the moment. *)
  induction n as [| n'].
  Case "n = O". reflexivity.
  Case "n = S n'".
    (* In the second subgoal generated by induction -- the
       "inductive step" -- we must prove that P n' implies
       P (S n') for all n'.  The induction tactic
       automatically introduces n' and P n' into the context
       for us, leaving just P (S n') as the goal. *)
    simpl. rewrite -> IHn'. reflexivity.
Qed.

Theorem plus_comm' : forall n m : nat,
  n + m = m + n.
Proof.
  induction n as [ | n' ].
  Case "n = O". intros m. rewrite -> plus_O_r. reflexivity.
  Case "n = S n'". intros m. simpl. rewrite -> IHn'.
  rewrite <- plus_n_Sm. reflexivity.
Qed.

Theorem plus_comm'' : forall n m : nat,
  n + m = m + n.
Proof.
  (* Let's do induction on m this time, instead of n... *)
  induction m as [| m'].
  Case "m = O". simpl. rewrite -> plus_O_r. reflexivity.
  Case "m = S m'". simpl. rewrite <- IHm'.
    rewrite <- plus_n_Sm. reflexivity.
Qed.

(* Exercise: 1 star, optional (plus_explicit_prop) *)

Definition plus_assoc_def (n m p : nat) : Prop :=
  n + (m + p) = (n + m) + p.

Theorem plus_assoc'' : forall (n m p : nat), plus_assoc_def n m p.
Proof.
  intros n m p.
  apply nat_ind.

  Case "p = O".
  unfold plus_assoc_def.
  rewrite ->2 plus_O_r.
  reflexivity.

  Case "p = S p'".
  unfold plus_assoc_def.
  intros p' IHp'.
  rewrite <-3 plus_n_Sm.
  rewrite <- IHp'.
  reflexivity.
Qed.

Definition plus_comm_def (n m : nat) : Prop :=
  n + m = m + n.

Theorem plus_comm''' : forall (n m : nat), plus_comm_def n m.
Proof.
  intros n m.
  apply nat_ind.

  Case "m = O".
  unfold plus_comm_def.
  rewrite -> plus_O_r.
  unfold plus.
  reflexivity.

  Case "p = S p'".
  unfold plus_comm_def.
  intros m' IHm'.
  rewrite <- plus_n_Sm.
  rewrite -> IHm'.
  rewrite <- plus_1_l.
  rewrite -> plus_assoc.
  rewrite -> plus_1_l.
  reflexivity.
Qed.

(* Exercise: 4 star, optional (true_upto_n__true_everywhere) *)

Fixpoint true_upto_n__true_everywhere (n : nat) (f: nat -> Prop) : Prop :=
  match n with
    | O => forall m, f m
    | S n' => even (S n') -> (true_upto_n__true_everywhere n' f)
  end.

Example true_upto_n_example :
    (true_upto_n__true_everywhere 3 (fun n => even n))
  = (even 3 -> even 2 -> even 1 -> forall m : nat, even m).
Proof. reflexivity.  Qed.

(* Building Proof Objects Incrementally *)

Definition b_16 : beautiful 16 :=
  b_sum 5 11 b_5 (b_sum 5 6 b_5 (b_sum 3 3 b_3 b_3)).

(* Additional Exercises *)

(* Exercise: 4 stars (palindromes) *)

(* A palindrome is a sequence that reads the same backwards as forwards. Define
   an inductive proposition pal on list X that captures what it means to be a
   palindrome. (Hint: You'll need three cases. Your definition should be based
   on the structure of the list; just having a single constructor

   c : forall l, l = rev l -> pal l
   may seem obvious, but will not work very well.)
   Prove that
   forall l, pal (l ++ rev l).
   Prove that
   forall l, pal l -> l = rev l. *)

(* TODO *)

(* Exercise: 5 stars, optional (palindrome_exercise) *)

(* Using your definition of pal from the previous exercise, prove that
   forall l, l = rev l -> pal l. *)

(* TODO *)

(* Exercise: 4 stars (subsequence) *)

(* TODO *)

(* Exercise: 2 stars, optional (foo_ind_principle) *)

(* TODO *)

(* Exercise: 2 stars, optional (bar_ind_principle) *)

(* TODO *)

(* Exercise: 2 stars, optional (no_longer_than_ind) *)

(* TODO *)

(* Exercise: 2 stars, optional (R_provability) *)

(* TODO *)

(* end-of-Prop.v *)